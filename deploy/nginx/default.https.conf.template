## Upstream notes
# Docker assigns containers new IPs when they are recreated.
# If nginx resolves service names once at startup, it can temporarily keep stale IPs and return 502.
# We force periodic DNS re-resolution via Docker's embedded DNS (127.0.0.11) by using variables.

# Use Docker embedded DNS for service discovery.
# Prefer `upstream ... resolve` over variable-based `proxy_pass` for stability.
resolver 127.0.0.11 valid=10s ipv6=off;
resolver_timeout 5s;

upstream backend_upstream {
  zone backend_upstream 64k;
  server backend:5000 resolve;
}

upstream frontend_upstream {
  zone frontend_upstream 64k;
  server frontend:80 resolve;
}

# Basic, practical abuse protection (lightweight)
# IMPORTANT: limits are per *public IP*. Several real users may share one IP (NAT).
# To keep real users smooth while still throttling bots:
# - Only rate-limit *anonymous* API calls (no Authorization header).
# - Never rate-limit /api/auth/* at nginx (backend has dedicated auth/login limiters).
map $http_authorization $anon_api_key {
  default "";
  ""      $binary_remote_addr;
}
limit_req_zone $anon_api_key zone=anon_api_per_ip:10m rate=20r/s;
limit_req_status 429;
limit_conn_zone $binary_remote_addr zone=conn_per_ip:10m;

server {
  listen 80;
  server_name ${SERVER_NAMES};

  # ACME challenge for Let's Encrypt (certbot)
  location ^~ /.well-known/acme-challenge/ {
    root /var/www/certbot;
    default_type "text/plain";
  }

  # Force HTTPS
  location / {
    return 301 https://$host$request_uri;
  }
}

server {
  listen 443 ssl http2;
  server_name ${SERVER_NAMES};

  ssl_certificate /etc/letsencrypt/live/${DOMAIN}/fullchain.pem;
  ssl_certificate_key /etc/letsencrypt/live/${DOMAIN}/privkey.pem;

  ssl_session_cache shared:SSL:10m;
  ssl_session_timeout 10m;
  ssl_protocols TLSv1.2 TLSv1.3;

  server_tokens off;
  # Allow larger uploads (library assets, videos, PDFs, etc.)
  # Keep in sync with backend multer limit (LIBRARY_UPLOAD_MAX_BYTES).
  client_max_body_size 250m;

  # Very light limits (keeps scanners from hammering)
  limit_conn conn_per_ip 100;

  add_header X-Content-Type-Options nosniff always;
  add_header X-Frame-Options SAMEORIGIN always;
  add_header Referrer-Policy strict-origin-when-cross-origin always;

  # Hard-block common scanning/probing paths
  location ~* ^/(?:\.env|\.git|\.hg|\.svn|\.DS_Store|\.ht|wp-admin|wp-login\.php|phpmyadmin|pma|adminer|vendor|cgi-bin) {
    return 444;
  }

  # Backend API
  # Auth endpoints are intentionally NOT rate-limited at nginx.
  # The backend has its own dedicated auth/login rate limiters.
  location ^~ /api/auth/ {
    proxy_pass http://backend_upstream;
    proxy_set_header Host $host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto https;
  }

  # Library streaming endpoints (PDF previews/downloads) can be large and slow.
  # Increase proxy timeouts and disable buffering to avoid 504s and partial loads.
  location ^~ /api/library/ {
    proxy_read_timeout 300s;
    proxy_send_timeout 300s;
    proxy_buffering off;
    proxy_pass http://backend_upstream;
    proxy_set_header Host $host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto https;
  }

  # Health/version are safe to exempt from nginx limits (backend also skips them).
  location = /api/health {
    proxy_pass http://backend_upstream;
    proxy_set_header Host $host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto https;
  }

  location = /api/version {
    proxy_pass http://backend_upstream;
    proxy_set_header Host $host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto https;
  }

  location ^~ /api/ {
    # Only affects anonymous requests. Authenticated requests have an empty key and
    # are effectively not rate-limited at nginx.
    limit_req zone=anon_api_per_ip burst=40 nodelay;
    proxy_pass http://backend_upstream;
    proxy_set_header Host $host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto https;
  }

  # Socket.io (websockets)
  location ^~ /socket.io/ {
    proxy_pass http://backend_upstream;
    proxy_http_version 1.1;
    proxy_set_header Upgrade $http_upgrade;
    proxy_set_header Connection "upgrade";
    proxy_set_header Host $host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto https;
  }

  # Everything else -> dashboard container
  location / {
    proxy_pass http://frontend_upstream;
    proxy_set_header Host $host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto https;
  }
}
