## Waraqa deployment runbook (DigitalOcean)

### Server

- Droplet IP: 159.89.40.84
- OS: Ubuntu 24.04
- User: root (key-only)

### Current status

- UFW enabled: yes (22 limited, 80/443 allowed)
- Root SSH from Windows: working (ed25519 key)

### Local machine

- Repo path: C:\waraqa
- SSH key used (Windows): %USERPROFILE%\.ssh\id_ed25519
- Public key (Windows): ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIKey6UiilW/2iiM6zIBr1zQttRDEQMK+7szsUR41if6e mohamed ismail@DESKTOP-8T43TLE

### Required values to fill (copy/paste exact values when known)

- GITHUB_REPO_URL: https://github.com/waraqaweb/WaraqaWeb.Dash.git
- DOMAIN (optional for HTTPS): REPLACE_WITH_DOMAIN (LetsEncrypt does NOT work on IP-only)
- CERTBOT_EMAIL (optional for HTTPS): REPLACE_WITH_EMAIL

---

# Step 0 (LOCAL): Push repo to GitHub (must be done before deploy)

Run in PowerShell from C:\waraqa:

```powershell
git status
git add -A
git commit -m "first review issues"
git push origin main
```

Verify nothing sensitive is tracked:

```powershell
git ls-files | findstr /i "node_modules"
git ls-files | findstr /i "\\build\\"
git ls-files | findstr /i "\.env"
```

---

# Step 1 (DROPLET): Fix SSH so root works from Windows

Symptom: `Permission denied (publickey)` from Windows.

If your droplet console shows `>` (stuck in a heredoc), type:

EOF

or press Ctrl+C.

On the droplet console as root (this REWRITES authorized_keys cleanly):

```bash
mkdir -p /root/.ssh
chmod 700 /root/.ssh
cp /root/.ssh/authorized_keys /root/.ssh/authorized_keys.bak.$(date +%F-%H%M%S) 2>/dev/null || true
cat > /root/.ssh/authorized_keys <<'EOF'
ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQCtp4W+2oBzwvG0sgfvoFv5s9W0KT6MektyytFL0twVwu8nJQenL7nW8295ppAYvYZa3jFms5ugP0WuEKftSDXr4LmOKfSFjwMMoNlhWaLtfDNdA/GfJpv0zvA1HVMCwr0/fYhhkOyf7heoU+ueKSxRSLIlb9mBFqnAmsLx3mNouiIZn7oiBHnxCY83Ma4UK+5aZm6PL82WQ8L8p5XtgD4uShDuiy9sLHnQR+wphWolWp6VRnPcb++S/45hfRJQqHWRDRt3YTc9Gov/vhmkiZUdqf7pb0Bjmzh9371+rGyAZAUL8bXu3ST1jj1txivkxxYwQc8dNTMQPXEmpcwnTASF rsa-key-20230927
ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIKey6UiilW/2iiM6zIBr1zQttRDEQMK+7szsUR41if6e mohamed ismail@DESKTOP-8T43TLE
EOF

chown root:root /root/.ssh /root/.ssh/authorized_keys
chmod 600 /root/.ssh/authorized_keys
cat -n /root/.ssh/authorized_keys
```

Then from Windows PowerShell:

```powershell
ssh -o IdentitiesOnly=yes -i $env:USERPROFILE\.ssh\id_ed25519 root@159.89.40.84
```

---

# Step 2 (DROPLET): Reboot once (recommended after apt upgrades)

On droplet:

```bash
reboot
```

If you prefer to avoid reboot right now, you can skip this and continue.

Reconnect from Windows:

```powershell
ssh -o IdentitiesOnly=yes -i $env:USERPROFILE\.ssh\id_ed25519 root@159.89.40.84
```

---

# Step 3 (DROPLET): Firewall (UFW) + SSH hardening (root-only)

## UFW

```bash
ufw default deny incoming
ufw default allow outgoing
ufw allow OpenSSH
ufw allow 80/tcp
ufw allow 443/tcp
ufw limit OpenSSH
ufw --force enable
ufw status verbose
```

## DigitalOcean Cloud Firewall (IMPORTANT)

If `curl -I http://127.0.0.1/dashboard/` works on the droplet but your browser times out, the usual cause is a DigitalOcean Cloud Firewall that allows SSH (22) but blocks HTTP/HTTPS.

In the DigitalOcean control panel:

- Networking -> Firewalls
- Find any firewall attached to this droplet
- Ensure **Inbound Rules** include:
  - TCP 22 (SSH) from your IP (or 0.0.0.0/0 if you accept the risk)
  - TCP 80 from 0.0.0.0/0 and ::/0
  - TCP 443 from 0.0.0.0/0 and ::/0

From Windows PowerShell (external test):

```powershell
Test-NetConnection 159.89.40.84 -Port 80
Test-NetConnection 159.89.40.84 -Port 443
```

## SSH hardening (keep root, key-only)

```bash
printf "%s\n" \
	"PermitRootLogin prohibit-password" \
	"PasswordAuthentication no" \
	"KbdInteractiveAuthentication no" \
	"ChallengeResponseAuthentication no" \
	"PubkeyAuthentication yes" \
	"X11Forwarding no" \
	> /etc/ssh/sshd_config.d/99-hardening.conf

sshd -t
systemctl reload ssh
```

---

# Step 4 (DROPLET): Fail2Ban (blocks brute-force SSH)

```bash
apt-get install -y fail2ban
printf "%s\n" \
	"[sshd]" \
	"enabled = true" \
	"maxretry = 5" \
	"findtime = 10m" \
	"bantime = 1h" \
	"backend = systemd" \
	> /etc/fail2ban/jail.d/sshd.local

systemctl enable --now fail2ban
fail2ban-client status
fail2ban-client status sshd
```

---

# Step 5 (DROPLET): Install Docker + Docker Compose plugin

```bash
install -m 0755 -d /etc/apt/keyrings
curl -fsSL https://download.docker.com/linux/ubuntu/gpg | gpg --dearmor -o /etc/apt/keyrings/docker.gpg
chmod a+r /etc/apt/keyrings/docker.gpg
echo "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu $(. /etc/os-release && echo $VERSION_CODENAME) stable" > /etc/apt/sources.list.d/docker.list
apt-get update -y
apt-get install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin
systemctl enable --now docker
docker version
docker compose version
```

---

# Step 6 (DROPLET): Clone and deploy (HTTP-only works on IP)

## Clone

```bash
mkdir -p /opt/waraqa
cd /opt/waraqa
git clone https://github.com/waraqaweb/WaraqaWeb.Dash.git .
```

## Create production env

```bash
cp .env.example .env
```

Generate secrets (paste into .env for JWT_SECRET and REFRESH_TOKEN_SECRET):

```bash
openssl rand -base64 48
openssl rand -base64 48
```

Set DOMAIN in .env (HTTPS requires a real domain; IP-only = leave DOMAIN as example.com and do NOT run certbot):

```bash
sed -i 's/^DOMAIN=.*/DOMAIN=159.89.40.84/' .env
sed -i 's|^FRONTEND_URL=.*|FRONTEND_URL=http://159.89.40.84|' .env
sed -i 's|^REACT_APP_API_URL=.*|REACT_APP_API_URL=http://159.89.40.84/api|' .env
sed -i 's|^REACT_APP_SOCKET_URL=.*|REACT_APP_SOCKET_URL=http://159.89.40.84|' .env
```

## Start containers

```bash
docker compose up -d --build
```

## Check

```bash
docker compose ps
docker compose logs -n 200 nginx
docker compose logs -n 200 backend
curl -sS http://127.0.0.1/api/health
```

Open in browser:

- http://159.89.40.84/dashboard/

---

# Step 6.25 (DROPLET): Prevent downtime after reboot (IMPORTANT)

## Do NOT install host nginx

This deployment already includes an nginx reverse-proxy **inside Docker** (service: `nginx`) that binds ports 80/443.
Installing host nginx will take port 80 and cause this error when starting Docker:

`failed to bind host port 0.0.0.0:80/tcp: address already in use`

If host nginx is installed (by mistake), remove it:

```bash
systemctl disable --now nginx 2>/dev/null || true
apt-get purge -y nginx nginx-common nginx-core 2>/dev/null || true
apt-get autoremove -y
rm -rf /etc/nginx
```

Then bring the Docker stack back:

```bash
cd /opt/waraqa
docker compose up -d --build
```

## Ensure the stack always comes back after reboot

Docker is already enabled; we also install a small systemd unit that runs `docker compose up -d` on every boot.

```bash
cd /opt/waraqa

cat > /etc/systemd/system/waraqa-compose.service <<'EOF'
[Unit]
Description=Waraqa Docker Compose stack
Wants=network-online.target
After=network-online.target docker.service
Requires=docker.service

[Service]
Type=oneshot
RemainAfterExit=yes
WorkingDirectory=/opt/waraqa
ExecStart=/usr/bin/docker compose up -d
ExecStop=/usr/bin/docker compose down
TimeoutStartSec=0

[Install]
WantedBy=multi-user.target
EOF

systemctl daemon-reload
systemctl enable --now waraqa-compose.service
systemctl status waraqa-compose.service --no-pager
```

## Optional: avoid surprise reboots (unattended-upgrades)

Ubuntu can install kernel updates automatically. This is good for security, but it can cause unexpected reboots.

To DISABLE automatic reboot (updates still install):

```bash
grep -R "Automatic-Reboot" -n /etc/apt/apt.conf.d/* || true

cat > /etc/apt/apt.conf.d/99-waraqa-unattended-reboot.conf <<'EOF'
Unattended-Upgrade::Automatic-Reboot "false";
EOF

systemctl restart unattended-upgrades || true
```

To ALLOW automatic reboot but at a fixed time (example: 04:00 UTC):

```bash
cat > /etc/apt/apt.conf.d/99-waraqa-unattended-reboot.conf <<'EOF'
Unattended-Upgrade::Automatic-Reboot "true";
Unattended-Upgrade::Automatic-Reboot-Time "04:00";
EOF

systemctl restart unattended-upgrades || true
```

---

---

# Step 6.3 (DROPLET): Incident playbook (site down)

Run these in order and paste output if you need help:

```bash
# 1) Is the droplet reachable?
uptime

# 2) Are ports open locally?
ss -ltnp | grep -E ':(80|443)\b' || true

# 3) Is Docker running?
systemctl status docker --no-pager
docker ps

# 4) Bring stack up
cd /opt/waraqa
docker compose up -d

# 5) Quick health checks
# NOTE: When HTTPS is enabled, http://127.0.0.1/* will 301 to https://127.0.0.1/*.
# That redirect is expected but not a useful health check.

# Wait briefly for backend to accept connections (avoids transient 502 right after restart)
for i in $(seq 1 30); do
	if docker compose exec -T nginx sh -lc 'wget -q -O- http://backend:5000/api/health >/dev/null'; then
		echo "Backend is healthy"
		break
	fi
	echo "Waiting for backend... ($i/30)"
	sleep 1
done

# If you know the domain:
DOMAIN=${DOMAIN:-test.waraqaweb.com}
curl -I https://$DOMAIN/dashboard/login || true
curl -sS https://$DOMAIN/api/health || true

# If DNS is not working yet, force Host + SNI to localhost:
curl -I http://127.0.0.1/dashboard/login -H "Host: $DOMAIN" || true
curl -kI https://127.0.0.1/dashboard/login --resolve "$DOMAIN:443:127.0.0.1" || true
curl -ksS https://127.0.0.1/api/health --resolve "$DOMAIN:443:127.0.0.1" || true

# 6) Logs
docker compose logs --tail=200 nginx
docker compose logs --tail=200 backend
docker compose logs --tail=200 mongo
```

## Common error: "service \"mongo\" refers to undefined volume mongo-data"

This means `/opt/waraqa/docker-compose.yml` got truncated/edited and is missing the bottom `volumes:` section.

Safe fix (does NOT delete the database):

```bash
cd /opt/waraqa

# Confirm the problem
docker compose config || true

# Restore compose file from git (safe)
git status --porcelain
git restore docker-compose.yml 2>/dev/null || git checkout -- docker-compose.yml

# Verify volumes section exists now
tail -n 30 docker-compose.yml

# Compose should validate now
docker compose config >/dev/null

# Start stack
docker compose up -d --build
# Re-start boot recovery service (if installed)
systemctl restart waraqa-compose.service 2>/dev/null || true
systemctl status waraqa-compose.service --no-pager 2>/dev/null || true
```

---

# Step 6.5 (DROPLET): Create the first admin user

This uses the existing backend script and writes the admin user into MongoDB.

IMPORTANT: `admin123456` is weak. Use it only temporarily, then change it immediately after first login.

```bash
cd /opt/waraqa

# Create admin (first run only)
docker compose exec \
	-e ADMIN_EMAIL="waraqainc@gmail.com" \
	-e ADMIN_PASSWORD="admin123456" \
	backend node scripts/createAdmin.js
```

If it says an admin already exists and you need to reset the password, run:

```bash
cd /opt/waraqa
docker compose exec backend node - <<'NODE'
const mongoose = require('mongoose');
const User = require('./models/User');
require('dotenv').config();

const email = 'waraqainc@gmail.com';
const newPassword = 'admin123456';

(async () => {
	await mongoose.connect(process.env.MONGODB_URI);
	const user = await User.findOne({ email });
	if (!user) {
		console.error('No user found for', email);
		process.exit(1);
	}
	user.password = newPassword; // will be hashed by User pre-save hook
	await user.save();
	console.log('Password updated for', email);
	await mongoose.disconnect();
})();
NODE
```

---

# Step 6.6 (DROPLET): Verify database is working

MongoDB runs inside Docker and is NOT exposed publicly (recommended).

```bash
cd /opt/waraqa
docker compose ps
docker compose exec mongo mongosh --quiet --eval "db.adminCommand({ ping: 1 })"
docker compose exec mongo mongosh --quiet --eval "show dbs"
docker compose exec mongo mongosh --quiet --eval "use waraqadb; db.users.countDocuments()"
```

NOTE: There is no "cPanel" for MongoDB by default on a droplet. The safe way to manage MongoDB is:

- Use `mongosh` inside the container (commands above), OR
- Use MongoDB Compass via an SSH tunnel (ask if you want the exact steps).

---

# Step 7 (OPTIONAL): HTTPS with Let's Encrypt (DOMAIN REQUIRED)

Only do this when your domain's DNS points to 159.89.40.84.

This project supports:

- `DOMAIN` = the Let's Encrypt certificate directory name (under `/etc/letsencrypt/live/<DOMAIN>`)
- `SERVER_NAMES` = what nginx answers for (space-separated)

## Phase A: Deploy on a temporary subdomain (example: test.waraqaweb.com)

1. DNS: create an A record:

- test.waraqaweb.com -> 159.89.40.84

Wait for DNS propagation, then verify from the droplet:

```bash
dig +short test.waraqaweb.com A
```

2. Update `.env`:

```bash
cd /opt/waraqa

sed -i 's/^DOMAIN=.*/DOMAIN=test.waraqaweb.com/' .env

if grep -q '^SERVER_NAMES=' .env; then
	sed -i 's/^SERVER_NAMES=.*/SERVER_NAMES=test.waraqaweb.com/' .env
else
	echo 'SERVER_NAMES=test.waraqaweb.com' >> .env
fi

sed -i 's|^FRONTEND_URL=.*|FRONTEND_URL=https://test.waraqaweb.com|' .env
sed -i 's|^REACT_APP_API_URL=.*|REACT_APP_API_URL=https://test.waraqaweb.com/api|' .env
sed -i 's|^REACT_APP_SOCKET_URL=.*|REACT_APP_SOCKET_URL=https://test.waraqaweb.com|' .env

grep -E '^(DOMAIN|SERVER_NAMES|FRONTEND_URL|REACT_APP_API_URL|REACT_APP_SOCKET_URL)=' .env
```

3. Rebuild with the new frontend URLs (no need for `docker compose down`):

```bash
cd /opt/waraqa
docker compose up -d --build
```

4. Issue the cert + enable HTTPS:

```bash
mkdir -p /var/www/certbot
apt-get install -y certbot

certbot certonly --webroot \
	-w /var/www/certbot \
	-d test.waraqaweb.com \
	--email REPLACE_WITH_EMAIL \
	--agree-tos --no-eff-email

docker compose restart nginx
```

5. Verify:

```bash
DOMAIN=test.waraqaweb.com

# Confirm HTTP redirects to the correct HTTPS domain (Host header matters)
curl -I http://127.0.0.1/dashboard/login -H "Host: $DOMAIN"

# Real checks
curl -I https://test.waraqaweb.com/dashboard/login
curl -sS https://test.waraqaweb.com/api/health
```

## Phase B: Move later to dashboard.waraqaweb.com

1. DNS: create an A record:

- dashboard.waraqaweb.com -> 159.89.40.84

Wait for DNS propagation:

```bash
dig +short dashboard.waraqaweb.com A
```

2. Expand the existing certificate to include the new name (keeps `DOMAIN=test.waraqaweb.com` as the cert directory):

```bash
certbot certonly --webroot \
	-w /var/www/certbot \
	--expand \
	-d test.waraqaweb.com \
	-d dashboard.waraqaweb.com \
	--email REPLACE_WITH_EMAIL \
	--agree-tos --no-eff-email
```

3. Switch the app URLs to the new domain and rebuild:

```bash
cd /opt/waraqa

if grep -q '^SERVER_NAMES=' .env; then
	sed -i 's/^SERVER_NAMES=.*/SERVER_NAMES=test.waraqaweb.com dashboard.waraqaweb.com/' .env
else
	echo 'SERVER_NAMES=test.waraqaweb.com dashboard.waraqaweb.com' >> .env
fi

sed -i 's|^FRONTEND_URL=.*|FRONTEND_URL=https://dashboard.waraqaweb.com|' .env
sed -i 's|^REACT_APP_API_URL=.*|REACT_APP_API_URL=https://dashboard.waraqaweb.com/api|' .env
sed -i 's|^REACT_APP_SOCKET_URL=.*|REACT_APP_SOCKET_URL=https://dashboard.waraqaweb.com|' .env

docker compose up -d --build
docker compose restart nginx
```

4. Verify:

```bash
curl -I https://dashboard.waraqaweb.com/dashboard/login
curl -sS https://dashboard.waraqaweb.com/api/health
```

---

# Step 8: Update + rollback

## Update to latest main

```bash
cd /opt/waraqa
git rev-parse HEAD > /opt/waraqa/.previous_deploy_sha
git pull --ff-only
docker compose up -d --build
```

## Rollback

```bash
cd /opt/waraqa
git checkout $(cat /opt/waraqa/.previous_deploy_sha)
docker compose up -d --build
```

## Logs

```bash
docker compose logs -f --tail=200 nginx
docker compose logs -f --tail=200 backend
docker compose logs -f --tail=200 mongo
```

---

# Canonical deploy workflow (safe / repeatable)

## A) Windows: push latest code to GitHub

Run in PowerShell from `C:\waraqa`:

```powershell
cd C:\waraqa
git status
git add -A
git commit -m "library issue"
git push origin main
```

## B) Droplet: pull + redeploy (keeps DB + env)

This does NOT delete MongoDB data and does NOT overwrite `.env`.

```bash
set -eu
cd /opt/waraqa

# Save rollback point (the version currently running)
OLD_SHA="$(git rev-parse HEAD)"
echo "$OLD_SHA" > /opt/waraqa/.previous_deploy_sha

# Update code safely
git pull --ff-only

# Rebuild ONLY what changed (faster; avoids unnecessary frontend rebuilds)
NEW_SHA="$(git rev-parse HEAD)"
CHANGED="$(git diff --name-only "$OLD_SHA..$NEW_SHA" || true)"

SERVICES=""
printf "%s\n" "$CHANGED" | grep -qE '^deploy/nginx/' && SERVICES="$SERVICES nginx"
printf "%s\n" "$CHANGED" | grep -qE '^backend/' && SERVICES="$SERVICES backend"
printf "%s\n" "$CHANGED" | grep -qE '^frontend/' && SERVICES="$SERVICES frontend"

if [ -z "${SERVICES// }" ]; then
	echo "No build-needed changes detected; restarting stack only"
	docker compose up -d
else
	echo "Rebuilding services:$SERVICES"
	# Note: frontend rebuild (vite build) can take several minutes on small droplets.
	docker compose up -d --build $SERVICES
fi

# Verify
docker compose ps

# Wait for backend to become reachable (nginx can start before node listens)
for i in $(seq 1 30); do
	if docker compose exec -T nginx sh -lc 'wget -q -O- http://backend:5000/api/health >/dev/null'; then
		echo "Backend is healthy"
		break
	fi
	echo "Waiting for backend... ($i/30)"
	sleep 1
done

# Prefer real domain checks when HTTPS is enabled
DOMAIN=${DOMAIN:-test.waraqaweb.com}
curl -I https://$DOMAIN/dashboard/login || true
curl -sS https://$DOMAIN/api/health || true

# If DNS is not working yet, force Host + SNI to localhost
curl -I http://127.0.0.1/dashboard/login -H "Host: $DOMAIN" || true
curl -ksS https://127.0.0.1/api/health --resolve "$DOMAIN:443:127.0.0.1" || true
```

## If users get logged out / login fails for a few minutes

If you see `429` responses in `docker compose logs nginx` for real users (especially `/api/auth/me` or `/api/auth/login`), the nginx HTTPS rate limiting is too aggressive.

With this repo version, nginx only rate-limits **anonymous** `/api/*` requests (bots) and does **not** rate-limit authenticated users.

Fix / redeploy:

```bash
cd /opt/waraqa
git pull --ff-only

# Nginx config change? Rebuild nginx. Backend change? Rebuild backend.
# If you're not sure, rebuilding nginx+backend is usually enough.
docker compose up -d --build nginx backend

# Confirm 429s are gone (nginx)
docker compose logs --tail=500 nginx | grep ' 429 ' || echo "No 429s in last 500 lines"
```

## Rapid diagnostics bundle (copy/paste)

When you report an incident (logout, login fails, random 429/401), run the blocks below on the droplet and paste the full output.

### 1) Host + containers health

```bash
set -eu
cd /opt/waraqa

echo "== time =="; date; echo
echo "== uptime =="; uptime; echo
echo "== disk/mem =="; df -h / /var 2>/dev/null || true; free -h || true; echo

echo "== docker compose ps =="; docker compose ps; echo
echo "== restart counts / oom ==";
docker inspect \
	--format '{{.Name}} restartCount={{.RestartCount}} oom={{.State.OOMKilled}} exitCode={{.State.ExitCode}}' \
	$(docker compose ps -q) | sort; echo

echo "== last 50 backend logs =="; docker compose logs --tail=50 backend; echo
echo "== last 50 nginx logs =="; docker compose logs --tail=50 nginx; echo
```

### 2) Nginx: are we rate limiting real users?

This summarizes nginx access-log status codes and shows recent 429 samples.

```bash
set -eu
cd /opt/waraqa

LOGS="$(docker compose logs --tail=20000 nginx | sed -E 's/^[^|]*\|\s*//')"

echo "== nginx status code counts (last 20k lines) =="
printf "%s\n" "$LOGS" \
	| awk -F'"' 'NF>=3{print $3}' \
	| awk '{print $1}' \
	| grep -E '^[0-9]{3}$' \
	| sort | uniq -c | sort -nr | head -n 20
echo

echo "== nginx 429 samples (last 50) =="
printf "%s\n" "$LOGS" \
	| awk -F'"' 'NF>=3{req=$2; status=$3; sub(/^ /,"",status); split(status,a," "); if(a[1]=="429") print $0}' \
	| tail -n 50
echo

echo "== top IPs hitting 429 (last 20k lines) =="
printf "%s\n" "$LOGS" \
	| awk -F'"' 'NF>=3{status=$3; sub(/^ /,"",status); split(status,a," "); if(a[1]=="429") print $1}' \
	| sort | uniq -c | sort -nr | head -n 20
echo

echo "== auth endpoints (login/me) status timeline (last 200 matches) =="
printf "%s\n" "$LOGS" \
	| awk -F'"' 'NF>=3{req=$2; status=$3; sub(/^ /,"",status); split(status,a," "); if(req ~ /^(GET \/api\/auth\/me|POST \/api\/auth\/(login|admin\/login))/){print a[1], $1, "|", req}}' \
	| tail -n 200
```

### 3) Nginx: confirm active rate-limit config (what nginx is really running)

```bash
set -eu
cd /opt/waraqa

echo "== nginx effective config snippets =="
docker compose exec -T nginx sh -lc \
	'nginx -T 2>&1 | grep -E "limit_req_status|limit_req_zone|limit_req |map \$http_authorization|location \^~ /api/auth/|location = /api/health|location = /api/version|return 444" || true'
```

### 4) Backend: confirm rate-limit env and trust proxy

```bash
set -eu
cd /opt/waraqa
echo "== backend env (rate limiting / proxy) =="
docker compose exec -T backend sh -lc 'env | grep -E "^(NODE_ENV|TRUST_PROXY|RATE_LIMIT_WINDOW_MS|RATE_LIMIT_MAX)=" || true'
```

### 5) Quick bot/scanner snapshot (optional)

This helps distinguish real-user issues from background internet scanning.

```bash
set -eu
cd /opt/waraqa

echo "== recent scanner probes (.env/.git/wp-login/phpmyadmin/etc) =="
docker compose logs --tail=20000 nginx \
	| sed -E 's/^[^|]*\|\s*//' \
	| grep -E '"(GET|POST) /(\.env|\.git|wp-login\.php|wp-admin|phpmyadmin|pma|adminer)' \
	| tail -n 50 || true

echo
echo "== fail2ban sshd status =="
fail2ban-client status sshd 2>/dev/null || true
```

## C) Rollback (safe)

```bash
cd /opt/waraqa
git checkout $(cat /opt/waraqa/.previous_deploy_sha)
docker compose up -d --build
```

## Uptime rules (avoid downtime)

- DO NOT install host `nginx` (Docker nginx binds 80/443).
- DO NOT run `docker compose down -v` (it deletes the MongoDB volume).
- For changes to domain/URLs, always run `docker compose up -d --build` (frontend rebuild required).
- Only paste command blocks into the droplet shell (never paste terminal output like "Reading package lists...").

---

# Step 9 (OPTIONAL but recommended): Auto-renew TLS certificates

If you used `certbot` on the droplet, enable auto-renew and restart the Docker nginx after renewal.

```bash
apt-get update -y
apt-get install -y certbot

# Confirm the systemd timer exists (Ubuntu default)
systemctl list-timers | grep -i certbot || true

# Install a deploy hook that restarts the nginx container after renew
cat > /etc/letsencrypt/renewal-hooks/deploy/restart-waraqa-nginx.sh <<'EOF'
#!/bin/sh
set -eu
cd /opt/waraqa
/usr/bin/docker compose restart nginx
EOF

chmod +x /etc/letsencrypt/renewal-hooks/deploy/restart-waraqa-nginx.sh

# Confirm hook exists
ls -la /etc/letsencrypt/renewal-hooks/deploy/

# Test renew (dry run)
certbot renew --dry-run
```
